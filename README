= Neo4j.rb

Neo4j.rb is a ruby wrapper around the Java Neo api.
See http://www.neo4j.org/

== Examples

Here are some examples of how to use the API.


=== Using transactions

Most operations on neo requires an transaction.
  include 'neo'

  Neo::transaction {
    node = Neo.new
  }

You have also access to transaction object

   Neo::transaction { |t|
     # something failed
     t.failure # will cause a rollback
   }


If a block is not given than the transaction method will return a transaction object.

   transaction = Neo::transaction
   transaction.begin
   # etc ...

=== Create a node

If a block is provided the node will be created in an transaction
  node = Neo.new { }


=== Set properties

You can set any properties without declaring them first
 
  # create a node with to properties 
  node = Neo::Node.new { |n|
     n.foo = "123"
     n.bar = "432"
  }
 
  # access those properties
  puts node.foo
  
If you want you can also declare those properties, like the attr_accessor

  class Foo < Neo::Node 
     properties :foo, :bar
  end

  Neo::transaction {
    f = Foo.new
    f.foo = "123"
   }

=== Using relationships

Relationships has to be declared first like this:

  class Foo < Neo::Node
     relations :bars
  end

Add a relation to a node:

  f = Foo.new { |n|
    n.bars < a_bar_node
  }


Traversing relationships:

  f.bars.each { |n| puts n }

Note that the bars method returns an object that mixins the Enumeration module.


=== Unmarshalling

The neo module will automatically unmarshalling nodes to the correct ruby class.
It does this by reading the classname property and loading that ruby class with that node.

  class Foo << Neo::Node
    def hello
    end
  end

  f1 = Foo.new {}
  
  # load the class again
  f2 = Neo::neo_service.find_node(foo.neo_node_id)
  f2.hello
  # f2.class == Foo

=== Referensing instances

Neo4j.rb will automatically store all instances in a MetaNode.
For example, let say you want to find all instance of class FooBar


      fb1 = FooBar.new
      fb2 = FooBar.new
      
      all = FooBar.meta_node.instances.to_a  # => [fb1, fb2]

=== Using mixins

If you do not want to inherit from Neo::Node you can use the Neo::NodeMixin instead
Example
  class MyNode
    include Neo::NodeMixin
    def initialize(*args, &block)
      init_internal_node(*args, &block)
    end
  end
  @node = MyNode.new

Notice that the init_internal_node method must be called in the initialize method.
It is not possible (???) to mixin a initialize method from the mixin.
Using super does not work when chaining initialize methods in mixins, see
http://groups.google.com/group/ruby-talk-google/msg/f38239bcaeb70648

