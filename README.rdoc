= Neo4j.rb

Neo4j.rb is a network database framework for JRuby.
 
It uses two powerful java libraries: neo4j and lucene.
The java neo4j library is a network-oriented database â€” that is, an embedded, disk-based, fully transactional Java persistence engine that stores data structured in networks rather than in tables. A network (or graph) is a flexible data structure that allows a more agile and rapid style of development (for example, no need for a database schema)
One of its strength is its fast traversal of relationship in a hugh node space (billion nodes/relationships/properties on single-machine hardware). 

Neo4j.rb also provides support for indexing and querying the node space by using the java lucene library.
Neo4j.rb wraps those two java libraries to make it behave like any other ruby persistance framework.

For more info, see http://www.neo4j.org/ and http://lucene.apache.org/java/docs/index.html


=== Neo4j::Node

Neo4j::Node is a mixin that lets instances to be stored as a node in the neo node space on disk.
A node can have properties and relationships to other nodes.

Example of how declare a class that has this behaviour:

  class MyNode 
     include Neo4j::Node
   end


=== Create a Node

If a block is provided then the creation of the instance will be performed in an
transaction, see below for more information on transactions.

  node = MyNode.new { }

=== Node Properties

You can set any properties, see example below.
Those properties will be stored on in the Neo database.

  # create a node with to properties in one transaction
  node = MyNode.new { |n|
     n.foo = "123"
     n.bar = "432"
  }
 
  # access those properties
  puts node.foo
  

You can also a property like this:

    f = SomeNode.new
    f.foo = "123"


=== Relationships

Relationships has to be declared first like this:

  class Foo 
     include Neo::Node
     relations :bars
  end

Add a relation to a node:

  f = Foo.new { |n|
    n.bars < a_bar_node
  }


Traversing relationships:

  f.bars.each { |n| puts n }

Note that the bars method returns an object that mixins the Enumeration module.

=== Transactions

All operations that work with the node space (even read operations) must be wrapped in a transaction.
Luckly neo4j.rb will automatically create a transaction for those operation that needs it if one is not already provided.

For example all get, set and find operations will start a new transaction if none is already not runnig (for that thread).

If you want to perfrom a set of operation in a single transaction, use the Neo4j::Transaction.run method:

Example

Neo4j::Transaction.run {
  node1.foo = "value"
  node2.bar = "hi"
}


==== Write Locks
Neo4j has write locks on nodes. 
That means that read operation on a node will be blocked if one thread in a transaction and has written to a property of that node. 
The lock will be released as soon as the thread holding the write lock finishes the transaction.


==== Rollback

Neo4j support rollbacks on transaction. Example:
Example:

  include 'neo4j'

  node = MyNode.new

  Neo4j::Transaction.run { |t|
     node.foo = "hej"
     # something failed so we signal for a failure 
     t.failure # will cause a rollback, node.foo will not be updated
  }


You can also run it without a block, like this:

   transaction = Neo4j::Transaction.new
   transaction.start
   # do something
   transaction.finish

=== Indexing

If you want you can also declare those properties, like the attr_accessor

  class SomeNode
     include Neo4j::Node
     properties :foo, :bar
  end


(TODO change name of properties to index)

=== Quering (using lucene)

All declared properties are automatically indexed by lucene.

Example

      class TestNode 
        include Neo4j::Node
        properties :name, :age
      end
    
      node = TestNode.new
      node.name = 'foo'
      node.age  = 42


      TestNode.find(:name => 'foo', :age => 42) # => [node]

=== Find all

For example, let say you want to find all instance of class FooBar


      fb1 = FooBar.new
      fb2 = FooBar.new
      
      all = FooBar.all  # => [fb1, fb2]

Neo4j.rb will automatically manage relationships between instances and classes in a MetaNode.
Each class that includes the Neo::Node mixin has a class instance variable to this MetaNode.
This MetaNode is used by the 'all' method to find all the instance of a certain ruby class.

This also works for inheritance, example

     class Foo
        include Neo::Node
     end 

     class Bar < Foo
     end

     f = Foo.new
     b = Bar.new

     Foo.all # => [f,b]
     Bar.all # => [b]


== Implementation details

=== MetaNodes

The Node mixin defines the ruby hook methods 'included' and 'inherited' which will be
called when someone includes the Neo::Node mixin or creates a subclass from a 
class that includes that mixin.

When the included or inherited methods are called it will create a
MetaNode that has a relationship to its instances.
When an instance is created, which includes the Neo::Node mixin, it
will add a relationship between the new node and its meta node. All
this logic is handled in the initialize method (initialize is like a
constructor in Java) which the Neo::Node mixin provides.
The initialize method will also update ancestors MetaNodes, so that
the referenses for ancestor classes and the new node will work as you
would expect.

=== Unmarshalling

The neo module will automatically unmarshalling nodes to the correct ruby class.
It does this by reading the classname property and loading that ruby class with that node.

  class Foo 
    include Neo::Node

    def hello
    end
  end

  f1 = Foo.new {}
  
  # load the class again
  f2 = Neo4j::Neo.instance.find_node(foo.neo_node_id)
  f2.hello
  # f2.class == Foo

